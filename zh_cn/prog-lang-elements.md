# 编程语言的基本要素：类型、多态与存储

我认为编程语言的三大基本要素是：

* 类型：类型系统与类型限定，影响纠错能力、抽象能力。
* 多态：多态与代码复用的方式，影响抽象能力。
* 存储：运行时存储组织，对性能起重要影响。



---



### 类型系统

#### 类型是什么？

##### 从计算机实现的角度看，类型是二进制数据与信息的对应关系

计算机内部的寄存器、内存、硬盘等存储的是二进制数据，但软件要处理的是信息。类型决定了这些二进制数据与软件要处理的信息的对应关系，如何将信息转换为二进制数据，如何将二进制数据解释为信息。

例如说，内存中某个地方有四个字节数据，而软件将这四个字节认为是一个浮点数。那么，软件就不会将这四个字节数据进行整数的运算，如果要运算也是先将其认为是浮点数再转换成整数。这四个字节的数据可能表示一个整数，但同样是整数含义也不同，整数可能是列表的长度，可能是列表中一个元素的索引，可能是某个东西的哈希值，可能是空间中的一个坐标值...... 表面上都是`int`，实际上含义往往不同，这其实是现在主流编程语言对类型细化不足的体现。

编码，是类型的定义。补码将一定范围内正、负的整数与二进制数据对应起来。字符编码（例如ASCII）将字符与二进制数据对应起来。为了存储实数，设计了浮点数的编码，不过实数有无穷多个，浮点数只能表示其中一些。

##### 从抽象的角度看，类型可以是集合

类型可以认为是取值对象的集合，例如整数类型是所有能表示的整数的集合。从这个角度看，对两个集合进行笛卡尔乘积就相当于得到两个元素的元组（tuple），例如说`int`和`double`乘起来得到`pair<int, double>`。对两个（不相交）集合进行或运算可以得到和类型（sum type, tagged union）。一个类型的集合的子集代表子类型。

##### 更抽象地看，类型是代数结构的构造

例如要定义自然数类型，不从计算机实现的角度看，光看数学上自然数的定义，是先定义0，然后说一个自然数的后继是另一个自然数，0的后继是1，1的后继是2。在Idris中可以这样构造自然数`Nat`：

```
data Nat = Z | S Nat    --Z是zero,S是successor
```

0是`Z`，1是`S Z`，2是`(S (S Z))`

通过这个类型定义可以定义自然数加法：

```
plus : Nat -> Nat -> Nat    --加法输入两个自然数输出一个自然数
plus Z     y = y            --零与y相加得到y
plus (S k) y = S (plus k y) --k的后继与y相加，得到k+y的后继
```



#### 动态语言有没有类型？

动态语言看起来可以不写类型，但实际上也是有类型的，只不过类型在运行时决定。一个对象，可以是整数，可以是字符串，这个对象的类型是在运行时确定的。而且，在写代码的时候，虽然可以不用明确写出类型，但程序员对每个对象的类型都有是概念的。如果你想把两个数加起来，写了`a + b`，而且你不想拼接字符串，那么你会认为a和b代表数，不会认为a和b代表字符串。程序员如果在写代码的时候不知道自己用的对象是什么类型，那么他无法写出正确的程序。

动态语言相对于静态的代价，主要是：

* 降低运行性能，增大性能优化难度。
* 降低纠错能力。
* 增加正确理解接口使用方式的难度。接口如果不标类型，不能直接知道要传什么东西进去。
* 不利于IDE的代码分析，阻碍改名、搜索等功能。

动态语言的好处，有：

* 不用写类型。
* 降低类型系统复杂度，不需要泛型，默认类型擦除。
* 让多态更方便。

#### 类型系统的特性

类型非常重要，因为类型与数据的运算是绑定的。例如说，进行整数加法，需要两个整数类型的数据，也只能对整数类型的数据进行运算，而浮点数加法是另一种运算，针对浮点数类型。所以说整数加法与整数类型相绑定，浮点数加法与浮点数类型相绑定。

类型系统可以对一个取值进行宽松的限定与严格的限定，例如Java中`String` 和 `Object`都可以表示字符串对象的引用，而`Object` 是宽松的限定，`String`是严格的限定。严格限定的好处，在于：

* 不允许软件不希望得到的非法值，增强编程纠错能力。例如Java中引用默认可以取null值，而Kotlin中可以表示不能取null值的引用类型，实现更严格的限定。
* 让程序员更好理解代码，更好理解API使用方法。
* 类型与操作是相互绑定的，更严格、具体的类型更适合于使用该类型独有的操作。例如说Java中一个存储字符串的列表，宽松的类型限定为`List`，具体严格的类型限定为`List<String>`，有了具体严格的限定，可以直接从列表中取出字符串而不是取出`Object`再转换。动态语言中，代码允许你对任何类型进行任何操作，但运行时进行的操作仍依托于类型。

动态语言对类型（几乎）没有任何限定。当然，程序逻辑实际上对类型有限定，只是代码没有明确表示出这种限定。

下面考察几种重要的类型系统特性：

##### 和类型(sum type, tagged union)

和类型表示一个类型可能是A或B，例如一个函数返回的值是正常结果或者错误信息，不可能既有正常结果也有错误信息，不可能没有正常结果也没有错误信息。面向对象允许定义子类型，但无法限定只有两个子类。支持和类型的语言有Rust, OCaml等，而主流语言C++，Java等语言没有内置和类型。

##### 子类型(subtype)

子类型就是指一个类型属于另外一个类型。面向对象通过继承产生子类型，例如`Sub`类继承`Base`类，则`Sub`类是`Base`类的子类型，每一个`Sub`类对象引用都可以当做`Base`类的对象引用。对接口(interface)的实现也产生子类型。面向对象的函数重载产生子类型多态(subtyping polymorphism)，后面将讲解。

子类型可以部分地表达和类型，例如说一个函数返回的内容，要么是`Result`要么是`Error`，有和类型的语言可以直接表达`Result | Error`，而用面向对象子类型也可以表达这一类型，先定义一个`ResultOrError`接口，再定义`Result`和`Error`都实现`ResultOrError`。但面向对象的设计思想是子类型很容易被扩展，可以定义第三个类实现`ResultOrError`接口，导致类型系统无法限定`ResultOrError`的具体取值。

##### 鸭子类型(duck typing)

一个生物体，如果看起来像鸭子，走起来像鸭子，叫起来像鸭子，那么它就可以当成鸭子。若标准的鸭子对象有`quack`方法（函数），我定义另一个假鸭子对象也有`quack`方法，那么就可以把假鸭子对象当做鸭子对象用，调用`quack`方法实现多态。动态语言都有鸭子类型特性，动态语言让多态变得更方便。

在编译时就能确定鸭子类型的接口的特性，则称之为结构化类型系统(structural typing)。

##### 泛型(generic)

泛型，可以理解为一种由类型（或值）生成出来的类型。C语言的指针、函数指针、数组等类型生成方式可以被认为是泛型。广义地来说，定义结构体、定义共用体（union）也是用泛型来生成类型。

用一些类型或值来生成类型，相当于定义了一个参数到类型的“函数”，这被称为参数类型(parametric type)。而依赖于值的参数类型，也可称为依赖类型(dependent type)。说一个语言有泛型，就是说提供了定义自己的参数类型的功能。例如C++的模板（C++模板的参数必须编译时确定）。

##### Hindley-Milner类型系统

Hindley-Milner类型系统是Haskell的类型系统，这个类型系统具有较强的类型推导能力，定义函数可以不用写参数类型与输出类型。同时支持let-polymorphism。不过与子类型不兼容。本文不进行详细讨论（因为我不懂）。

##### 依赖类型(dependent type)

依赖类型指一个类型依赖于值。C++的模板参数既允许类型又允许值，支持依赖类型，不过依赖的值必须编译时确定。例如说C++中五个整数的数组`array<int, 5>`这里这个类型依赖于`5`，就是依赖类型。

Idris语言支持依赖类型，甚至通过细化的类型限定，通过类型检查证明程序大致的正确性。本文也不进行详细讨论（也是因为我不懂）。

##### 细化类型(refinement type)

细化类型可以认为是将断言加到类型里面，将类型限定进一步细化。例如说限定整数中大于5的整数作为一个类型，就是由整数类型与一个断言谓词`x > 5`组成细化类型。F*语言有细化类型。

细化类型之间的关系需要程序证明，例如说`x > 2`的整数是`x * x > 4`的整数的子类型，但确定这个子类型关系需要进行证明，而很多复杂情况下证明不了（假如能轻松证明，停机问题就可解）。

主流语言往往不支持细化类型而是使用合约(contract)，在程序运行时进行断言检查，例如每次访问数组都检查索引有没有越界。



---



### 多态与代码复用

为了降低bug出现几率，增强开发效率，让代码简洁、清晰，采用的方法之一就是代码复用。

代码复用是为了消除逻辑重复的代码。首先，为了消除完全一样的重复过程式代码，发明了宏、函数（子程序）这种最基础的代码复用技术。然后，仍然有很多大量逻辑相似的重复代码无法被消除、复用，这些代码不是完全一样的，他们大致逻辑一样，但内部有一些地方不一样，这个时候为了复用代码，需要保留一样的逻辑框架，并将不一样的地方抽成多态(polymorphism)。

#### 多态是什么？

多态指根据不同的类型，将一处调用分派到不同代码进行运行的机制。同时，泛型也是多态。从另一种角度讲模糊了数据与代码的界限。下面通过例子解释多态：

#### 函数对象、闭包与lambda表达式

两段逻辑相似的过程式代码代码，大致逻辑相似但里面一部分不一样，这时候会想到将不一样的部分抽为对函数对象的调用，并在外面的参数中输入函数对象，这样就可以实现代码复用了。

例如说，我用C语言写了一个在整数数组中顺次搜索第一个正整数位置的代码：

```C++
int indexOfFirstPositiveNumber(int* array, int arrayLength) {
   for (int i = 0; i < arrayLength; i++) {
       if (array[i] > 0) { return i; }
   }
   return -1;
}
```

后来又写了一个在整数数组中搜索第一个负数的代码：

```C++
int indexOfFirstNegativeNumber(int* array, int arrayLength) {
   for (int i = 0; i < arrayLength; i++) {
       if (array[i] < 0) { return i; }
   }
   return -1;
}
```

然后又写了搜索在`low`与`high`之间整数的代码：

```C++
int indexOfFirstNumberWithinRange(int* array, int arrayLength, int low, int high) {
   for (int i = 0; i < arrayLength; i++){
       if (array[i] < high && array[i] > low) { return i; }
   }
   return -1;
}
```

这三段代码逻辑相似，只有`if`里面的判别条件（谓词，predicate）不同，现在我想要进行代码复用，那么就要将`if`中的判别表达式抽出来，抽到参数里面。首先考虑到函数指针：

```C++
int indexOf(int* array, int arrayLength, bool(*predicate)(int)) {
   for (int i = 0; i < arrayLength; i++){
       if (predicate(array[i])){ return i; }
   }
   return -1;
}
```

这个时候，搜索正数的代码变为：

```C++
bool isPositive(int i) { return i > 0; }
indexOf(array, arrayLength, &isPositive)
```

搜索负数的代码也可以如此复用。但是这里遇到了问题：搜索在`low`与`high`之间整数的代码不能复用`indexOf`，因为要传入的函数`functionPointer`需要将数与`low`和`high`比较。但是这个函数指针只能指向一个函数，这个函数的参数只有一个数字，而函数里面要用到`low`和`high`。可以想到用全局变量来传递`low`和`high`，但这个方法在多线程或递归的时候不能用，而且全局变量不利于抽象。我们想把`low`和`high`跟函数指针一起传进去，将函数指针与`low`和`high`组成**闭包函数**。lambda表达式允许在定义函数的时候捕获外面的变量，组成闭包函数。

用C++，将接受函数指针改为接受闭包函数（lambda表达式）

```C++
int indexOf(int* array, int arrayLength, std::function<bool(int)> predicate) {
   for (int i = 0; i < arrayLength; i++) {
       if (predicate(array[i])) { return i; }
   }
   return -1;
}
```

搜索在`low`与`high`之间整数的代码复用`indexOf`，可以这样：

```C++
indexOf(array, arrayLength, [=](int element) { return element < high && element > low; })
//lmabda捕获了外面的high和low
```

这里的函数指针、闭包函数都是多态的方法。多态，可以被认为是代码分派(dispatch)，调用`predicate(number)`的时候，根据predicate具体值的不同，执行的代码被分派到不同的代码，这就是分派。

#### 面向对象与子类型多态

上面闭包函数实现的多态，从另一个角度来看也可以由面向对象子类型实现。这里用Java举例子：

定义函数对象的类型：

```java
interface IntPredicate{
    boolean test(int number);
}
```

定义可以复用的`indexOf`

```java
public static int indexOf(int[] array, IntPredicate predicate) {
    for (int i = 0; i < array.length; i++) {
        if (predicate.test(array[i])) { return i; }
    }
    return -1;
}
```

定义具体的闭包函数并调用：

```java
class WithinRange implements IntPredicate{
    public final int low, high;
    WithinRange(int low, int high) {...}
    @Override
    boolean test(int number) {return number > low && number < high;}
}
...
int low = 2; int high = 10;
indexOf(array, new WithinRange(low, high))
```

这里，`WithinRange`是`IntPredicate`的子类型，这被称为子类型多态。

Java也提供了lambda表达式：

```java
indexOf(array, (num) -> num > low && num < high)
```

可以看到，面向对象多态与闭包函数有类似的本质。

当然，面向对象多态能实现比闭包函数更多的功能，包括：

* 一个对象可以重载多个函数
* 对象可以包含可变数据
* 继承可以表示分类关系

##### 基于原型的面向对象

JavaScript作为动态语言，提供了独特的基于原型(prototype)的面向对象机制。JavaScript通过原型来实现类似继承、多态的效果。

在传统的静态面向对象语言例如C++和Java中，成员函数不能像成员变量一样随便赋值。但JavaScript中成员函数像成员变量一样可以赋值，成员函数相当于成员变量存在对象里面，通过“鸭子类型”实现多态。

JavaScript中继承用原型的方法表示，先有一个原型对象，相当于父类对象，然后根据原型创造新对象，新对象继承了原型对象的一切，相当于子类对象，创造新对象后添加一些与原型同名的成员变量和成员函数来实现覆盖，覆盖成员函数相当于重载函数。对没有被覆盖的成员，访问的时候访问到的是原型的成员，有继承的效果。

##### 非侵入式接口

C++与Java中，一个类实现了哪些接口，必须在声明的时候写全。而Rust和Go允许在声明一个类后，让这个类实现新的接口，显然这个设计使得扩展性更好，我可以自己定义一个新接口，并让现有的类实现自己的新接口。同时，能实现更好的解耦。

#### 参数多态与泛型

参数多态(parametric polymorphism)里的参数指泛型参数。例如说，我们写数组上的顺次搜索的代码，这次要返回找到的元素而不是索引。写了针对String和Integer两个类型的搜索代码：

```java
public static String findInStringArray(String[] array, StringPredicate predicate){
    for (int i = 0; i < array.length; i++){
        if (predicate.test(array[i])){ return array[i]; }
    }
    return null;
}
public static Integer findInIntegerArray(Integer[] array, IntegerPredicate predicate){
    for (int i = 0; i < array.length; i++){
        if (predicate.test(array[i])){ return array[i]; }
    }
    return null;
}
```

这也是重复代码，需要消除并复用。此时可以考虑类型擦除的方法：将`String`和`Integer`都包装为`Object`，即可轻松复用代码。

```java
public static Object find(Object[] array, ObjectPredicate predicate){
    for (int i = 0; i < array.length; i++){
        if (predicate.test(array[i])){ return array[i]; }
    }
    return null;
}
```

动态语言就是采用了类型擦除的方法，来简化参数多态。我们看到这个做法有一定缺点：

* 降低类型系统纠错能力，可以传入String数组和Integer谓词
* 返回的Object需要手动类型转换才能用

如果不考虑类型擦除的方法，我们考虑`findInStringArray`和`findInIntegerArray`，他们不同之处在于类型，为了实现代码复用，要将不同的地方抽出来，那么我们就将类型抽出来变成参数，也就是泛型。

```java
public static <T> T find(List<T> array, Predicate<T> predicate){
    for (int i = 0; i < array.size(); i++){
        if (predicate.test(array.get(i))){ return array.get(i); }
    }
    return null;
}
```

（Java的泛型在运行时是类型擦除的，泛型主要只存在于编译时。而C++的模板泛型，是对不同类型生成不同代码，在编译时根据类型进行分派。）

总而言之，代码复用就是保留相同的代码逻辑结构，将代码中不同的地方变成多态抽到参数里面。如果不同的地方是一块过程式代码，则抽出闭包函数，若不同的地方是类型，则抽出泛型。（如果不同的地方是好几块过程式代码与一些可变数据，则将把这些东西用面向对象继承的多态抽出。）

##### 协变与逆变

当子类型与泛型结合起来，就产生了协变与逆变的问题。（动态语言放弃了类型限定，没有这个问题，简化了泛型。）

考虑这个Java代码：

```java
String[] stringArray = new String[2];
Object[] objectArray = stringArray;
objectArray[0] = new Integer(0);
```

第三行允许编译但运行时会出错。`stringArray`的类型是`String[]`，这个类型要求数组只能存String，不能存Integer。但Java允许将`String[]`转为`Object[]`，如果你只是读取`objectArray`，读到的对象是`String`对象，而`String`是`Object`的子类型，这没有问题。

`String`是`Object`的子类型，但`String[]`不是`Object[]`的子类型。

怎样将这个类型限定严谨化呢？首先`String[]`不是`Object[]`的子类型，那么`String[]`不应该能转换成`Object[]`，但是如果`Object[]`是只读的数组，这是不违反类型限定的。所以，`String[]`应该只能转换为只读的`Object[]`。定义只读的数组的接口：

```Java
interface ArrayReadAccess<T> {
    T get(int index);
}
```

（Java语言中数组没有实现这种接口，这里只是用Java做示例。）

`String[]`应该实现`ArrayReadAccess<String>`，然后`ArrayReadAccess<String>`可以自动转换为`ArrayReadAccess<Object>`。这里，如果`String`是`Object`的子类型，则`ArrayReadAccess<String>`也是`ArrayReadAccess<Object>`的子类型，合成类型的子类型关系与类型参数的子类型关系一致，可以说`ArrayReadAccess`是协变(covariant)的。

那么我们再类似地定义数组写入的接口：

```java
interface ArrayWriteAccess<T> {
    void set(int index, T object);
}
```

显然，一个`Object[]`可以写入`String`，但`String[]`不能写入`Object`。所以`ArrayWriteAccess<Object>`是`ArrayWriteAccess<String>`的子类型。注意到`String`是`Object`的子类型，这里合成类型的子类型关系与类型参数的子类型关系相反，是逆变(contravariant)的。

##### 高阶泛型

普通函数是接受值作为参数，而高阶函数可以接受函数作为参数。泛型可以认为是一种接受类型输出类型的函数（在Idris语言中就是这样）。高阶泛型，类似于高阶函数，其泛型参数可以是一个泛型而不是具体的类型。

C++支持高阶泛型，例如这段C++代码在模板参数上指明容器的类别，并返回一个装有整数0的该容器：

```c++
template<template<class> class Container>
Container<int> getContainerContainingZero() {
    Container<int> container;
    container.push_back(0);
    return container;
}
std::vector<int> a = getContainerContainingZero<std::vector>();
std::list<int> b = getContainerContainingZero<std::list>();
```



#### 特设多态

特设多态(ad-hoc polymorphism)指一个函数根据其参数类型的不同分派到不同的代码。C++的函数重载允许编译时的特设多态，例如：

```C++
void print(int i) {printf("%d",i);}
void print(const char* str) {printf("%s",str);}
print(2);
print("hello world");
```

`print`函数，根据参数的类型是`int`还是`const char*`，分派到了不同的函数，这就是特设多态。同时，C++的运算符重载也是编译时的特设多态。

面向对象的子类型多态跟特设多态很像，都是根据对象的具体类型进行分派，但是子类型多态只能适用于存在子类型关系的类型，而特设多态不要求子类型关系。

Java的Object类有一个`equals`函数，`equals`接受`Object`参数，这个类型限定不充分，在实现`equals`函数的时候要将`Object`类型的引用转化为自己类的引用，这是对子类型多态的不良使用，显然对`equals`使用特设多态更好。

##### 单派发与多重派发

前面的`print`函数是单派发(single dispatch)，他根据一个参数的类型来决定派发到哪个函数。而多重派发(multiple dispatch)是通过多个参数的类型决定派发到哪个函数。例如想要计算两个物体是否相交，物体分为长方体、球、四面体，每两种不同物体相交判别代码都不一样：

```
boolean collides(Shape a, Shape b);
boolean collides(Box a, Sphere b) {...}
boolean collides(Sphere a, Box b) {...}
boolean collides(Box a, Tetrahedron b) {...}
```

他根据两个参数来进行派发，所以叫多重派发。Julia语言支持运行时的多重派发。面向对象的子类型多态是单派发。

#### 强制多态

强制多态(Coercion Polymorphism)，指通过自动类型转换实现多态，例如一个接受`long`的函数也可以接受`int`，调用时将`int`转化为`long`。



---



### 运行时存储组织

运行时存储组织与语言的性能密切相关。CPU的性能随着摩尔定律大幅度增长，而内存的延迟降低并没有赶上CPU的性能增长，导致现代软件的性能瓶颈往往是内存读取延迟。内存延迟比CPU延迟高，CPU经常因为缓存失效将大量时间用于等待内存读取。解释型语言在进行了JIT优化后，性能的极限往往是由内存布局决定的。

解释型语言（例如Java）一开始性能比原生语言（例如C）慢，主要性能瓶颈在于解释器。解释器本身大幅度增加了运行代码时CPU要执行的指令数量，而且每执行一条指令都是一个分支，大量的分支使CPU中的指令重排、寄存器重命名等无法工作，导致流水线几乎失效。在实现了JIT后，解释型语言的主要性能瓶颈在于内存布局（运行时存储组织）。（除了内存布局，解释型语言的安全检查也影响性能，例如说每次访问数组都要检查是否越界。但安全检查一般不是性能的瓶颈。）

同时，一个语言运行时存储组织与其类型系统的特性、多态特性紧密结合。

不同语言运行时存储组织的不同特性：

#### 手动管理内存 vs 垃圾回收

手动管理内存的语言，主要为C/C++，Rust，对动态分配的内存确定性地手动释放，一般不需要GC。C/C++语言方面对内存安全没有严格检查，可能会出现内存管理方面的错误，包括使用已释放内存、未释放内存导致内存泄漏、两次释放内存等。对C/C++，内存问题往往很难debug。而Rust通过所有权与借用检查来实现内存安全（尽管不保证内存不泄露），而借用检查系统往往会使编码变得困难，对初学者有“反人类”倾向。

C++与Rust都尝试对手动内存管理进行抽象。C++的手动内存管理抽象带来心智负担：传值还是传引用还是传指针？对于容器类型，传值容易复制，传指针容易出内存错误，传引用的话要不要`const`？一不小心存了容器内对象的指针，在容器扩容时才触发内存错误。要不要用智能指针？参数要不要传右值引用？...... 而Rust的所有权系统与借用检查，也是带来大量心智负担，经常和编译器作斗争。

其他语言，有自动垃圾回收，同时对内存访问做限制，能访问到的内存不会被垃圾回收，不能访问到的内存会被垃圾回收，不出内存问题。而垃圾回收会带来额外性能负担。早期的垃圾回收，需要整个程序暂停较长时间，而现代垃圾回收往往将一些步骤并行化，降低暂停时间，最新的垃圾回收已经可以达到暂停时间1ms以下。但就算再优化，垃圾回收仍有性能代价。延迟低的垃圾回收算法往往吞吐量低。垃圾回收的标记信息占用了一些内存，占用了一些CPU资源，占用了一些内存带宽，增加了耗电量。

手动管理内存不总是比垃圾回收快。在短时间内释放大量对象且活对象较少的情况下，基于Mark and Compact的GC能比普通的一小块一小块的内存释放更快。同时，Mark and Compact GC在移动对象的同时减少了内存碎片。

#### 静态对象存储 vs 动态对象存储

对于静态类型语言，一个对象有多少成员是固定的，每个成员在对象内的位置也是固定的。而动态语言允许通过名字来动态添加、删除对象成员，一个对象相当于一个字符串到对象的映射（map, dictionary），性能损失更多，缓存友好性更差。出色的运行时（例如JavaScript的V8）可以分析代码用到了哪些成员，提前确定一部分成员的内存布局，提高性能。但运行时的代码分析不可能是完备的，就算进行了分析仍要保留动态部分，无法优化到和静态类型一样的布局。

#### 值类型 vs 装箱

自动管理内存的语言中，Java不支持值类型，而C#支持值类型（struct）。例如说要使用三个浮点数组成的向量，Java中向量必须存在堆上，不能存在栈上，内存布局更分散，对缓存不友好。如果进行向量运算，产生大量堆上临时向量对象，则产生巨大GC压力。将向量存在栈上则没有这个性能代价。同时，Java中泛型不支持原始类型，必须装箱，一个整数的列表不能写`List<int>`而必须写`List<Integer>`，里面存的整数是装箱到对象里的，缓存不友好。如果要优化，得使用额外定义的`IntegerList`，`FloatList`等打破了泛型的代码复用。

Java采用类型擦除的方式实现泛型，则很难加入值类型。类型擦除使得泛型合成的不同类型只在编译时区分，在运行时共用一个类型擦除的类，这使得实现较为方便，但难以与值类型结合。类型擦除中，不同类型的引用的占内存大小相同，可以一视同仁，而对于值类型，不同类型的占内存大小不一样，无法与类型擦除式泛型结合，只能适用于模板式泛型（C++，C#）。

#### 虚函数表指针 vs 胖指针

C++语言的多态对象中有虚函数表指针，虚函数表指针本身携带了类型信息，调用多态函数的时候通过虚函数表指针找到真正执行的函数的指针。如果继承了三个类，则对象内部有三个虚指针。对于Java语言，不同的虚拟机实现方式不一样，但都是在对象内部携带类型信息。

而支持非侵入式接口的Rust语言不将类型信息存在对象里面，而是存在指针里面。Rust中的多态对象引用（trait指针）是“胖指针”，同时包括对象数据的指针以及对象的具体类型信息。

#### 对程序运行状态的存储

程序本身运行的状态，有代码位置、栈、寄存器等。支持异常的语言可以通过异常从内层函数跳到外层。支持协程(coroutine)的语言可以保存程序运行状态、暂时跳出并在后面跳回来，通过对代码进行CPS变换也可以做到这一点。

而对于没有可变性的语言(如Haskell)，理想状况下程序运行没有状态。

#### 不可变性

主流静态语言一般支持将一部分内存中数据标为不可变，这可以增强类型系统的纠错能力且为编译器优化提供更多信息。

Haskell语言中所有量都是不可变的，完全不可变的优点有：

* 易于并行化，不存在多线程竞争
* 可以进行惰性求值的优化（但惰性求值也容易导致内存泄漏）

而完全不可变的缺点，主要是难以处理本身具有可变性质的事物，例如：

* IO。IO本身是带状态的。网络访问有等待、成功、出错等可变状态，鼠标的位置本身是可变的状态，屏幕内容也是可变的状态...
* 随机数生成。随机数每生成一个都要改变内部状态。在Haskell中用随机数生成器，需要把随机数生成器在所有用到随机数的地方传递。
* 场景模拟。例如游戏，游戏中的场景在不断发生变化。
* ...

完全不可变带来诸多麻烦，而局部的不可变往往能带来复杂度的降低。



---



### 编程语言的其他要素

除了上述的类型、多态、存储三要素之外，有没有漏掉什么呢？

#### 编程范式

编程范式有：

* 命令式编程。主流语言都支持命令式编程。命令式编程对应的计算模型是图灵机。图灵机可以认为是一个一个指令顺次执行且有大量内部状态在不断变化。

* 函数式编程。纯粹函数式编程语言有Haskell等。函数式编程对应的计算模型是Lambda calculus，不包含可变状态，通过对表达式的求值完成计算。纯函数式编程跟命令式相比是一套全新的思维方式，例如用递归代替循环。

* 逻辑式编程。逻辑式编程语言有Prolog。本文没有讨论（又是我不懂的地方）。

现在的主流语言都是命令式编程语言，主流的计算机架构都是基于图灵机模型的、包含可变状态的计算机，对命令式编程运行性能最高。有许多函数式语言不是纯函数式的，他们引入了可变性，这使得程序可以更好处理IO等本身有状态的事务，混合了命令式编程特性。主流语言一般都是命令式函数式混合的。

（编程范式其实也可以算在基本要素里面，我没有算进去主要因为主流语言一般都是命令式函数式混合的。）（三大基本要素有四个不是常识吗，手动狗头）

#### 命令式语言的执行流程控制

命令式语言的的执行流程控制方法（代码跳转方法）有：

* 底层的跳转与条件跳转指令。`goto`语句。
* 函数调用（子程序调用）。
* 结构化编程，`if` `while` `for` `switch`等控制结构，辅以 `break` `continue` 等操作。
* 异常。函数内层抛出异常，外层捕获，实现控制流跳出。
* 协程。程序主动跳出，过一会再跳回来，手动进行上下文切换(context switch)。从另一角度相当于把控制流变成状态机。

#### 并行化支持

没有可变数据的计算易于并行化，因为没有并行带来的竞争，不需要同步。主流语言配合同步操作等可以进行多线程并行。Shader语言天生就是并行的。

#### 语法细节

古老的C++和Java语言受到C的影响类型在变量名前面，而新语言往往类型后置。受C语言影响，大多数语言用圆括号表示函数调用，用逗号分隔不同参数，用`=`表示赋值而不是更古老的`=:`，由于`=`被占用所以用`==`表示相等判断，作用域用花括号，数组用方括号。受C++影响，泛型一般用尖括号。函数式语言那边，函数调用中函数名和参数放在同一个括号下，不用逗号分隔参数，这与函数式语言的currying特性相关。

#### 语法糖

例如模式匹配，往往与和类型配合使用。

#### 数据解释为代码

函数式编程有一种重要思想，就是先定义一些基本的、功能单一的组件，再将组件嵌套组合起来形成复杂软件。这本身相当于自己定义了领域专用语言（DSL）以及一套解释器，模糊了数据与代码的界限。



---



### 总结

计算机发明几十年来出现了许多编程语言，而通过类型、多态、存储三方面对编程语言进行剖析，可以更全面地了解、分析、比较各种编程语言。如果一个新语言只是对现有语言的特性的组合，通过这种分析可以轻易了解这一语言。

工程上对编程语言的选择需要进行取舍。不同的编程语言，其开发效率、软件性能与质量、程序员满意度不同。例如Rust开发的软件质量高但程序员开发轻松度较低。C++从满足程序员装逼需求方面很好（学术化语言太小众太抽象不适合装逼，C++的复杂度主要是细节方面的更容易学而且知名度高刚好适合装逼）。Python在开发小型软件方面效率较高，而大型软件容易动态类型火葬场。灵活性与纠错能力往往矛盾。抽象与性能优化往往矛盾。主流语言有生态优势，但新语言有更好的特性。

现在编程语言的发展趋势是，主流语言借鉴（抄袭）其他语言的优良特性，例如C++、Java和Python从函数式语言借鉴lambda表达式，C#、JavaScript，C++加入协程。动态语言也在不断借鉴静态语言的优势，Python加入类型标注，TypeScript得到广泛运用。连专注于Keep it simple and stupid原则的Go语言也在加入泛型。

未来的编程语言会怎样发展？只有未来的人知道。软件开发效率发展到极致是AI编程，而能理解产品需求的AI必然是强AI，能代替包括程序员的大部分工作岗位。弱AI能否帮助编程？GPT-3已经能编简单的程序。随着现有的轮子越来越多，未来是否可以普遍实现低代码开发？C语言和Haskell语言差别大吗？大。但是跟可能存在的外星人的语言比呢（例如《降临》中的七肢桶语言，与人类语言有本质上的不同）？量子计算机的发展是否会带来新的编程范式？让我们拭目以待。



（本文可能不定期更新）

